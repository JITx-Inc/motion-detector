; ====================
; A number of helpful functions to implement your design, export to CAD, 
; update your design in CAD, etc.
; ====================
#use-added-syntax(jitx)
defpackage helpers :
  import core
  import jitx
  import jitx/commands
  import jitx/parts

  ; import ocdb/utils/generic-components
  import ocdb/utils/generator-utils
  import ocdb/utils/property-structs

  import jsl/bundles
  import jsl/design/E-Series

  import board

;===============================================
; new component query interface
;===============================================
public var DISTRIBUTORS = ["JLCPCB"]
public var PART-QUANTITY = 1000
public var MOQ = 1000

set-global-query-defaults!(min-stock = PART-QUANTITY, quantity-needed = MOQ, price = FindMinimum)

public var OPERATING-TEMPERATURE = min-max(0.0, 50.0)
; public val general-query = BaseQuery(sellers! = ["DigiKey" "Future" "Mouser" "Arrow" "Avnet" "Newark"])
public val general-query = BaseQuery(sellers! = DISTRIBUTORS)
public val smd-query = add(general-query,
                            mounting = "smd"
                            case = valid-smd-pkgs("0402"),
                            operating-temperature = OPERATING-TEMPERATURE
                          )

public val cap-query = CapacitorQuery(smd-query,
                                      type = "ceramic",
                                      temperature-coefficient_code = ["X7R" "X5R"],
                                      rated-voltage = 6.0,
                                      sort! = SortKey(rated-voltage = Increasing)
                                      )

public val c0g-cap-query = CapacitorQuery(smd-query,
                                            type = "ceramic",
                                            temperature-coefficient_code = "C0G",
                                            sort! = SortKey(rated-voltage = Increasing)
                                          )

public val res-query = ResistorQuery(smd-query)

public val ind-query = InductorQuery(smd-query)


; setup-design(current-dir = "nrf-design-final" shape = board-shape paper = ANSI-B)

public defn setup-design (-- current-dir:String = "jitx-design" shape:Shape = Rectangle(30.0, 30.0) paper:Paper = ANSI-A) :
  set-current-design(current-dir)
  setup-bill-of-materials(PART-QUANTITY, DISTRIBUTORS)
  set-paper(paper)
  setup-board(shape)
  setup-export()

public defn setup-export () :
  set-use-layout-groups()
  set-export-backend(`kicad) ; set the CAD software for export to be `altium or `kicad)


; ====================
; Actual Export design
; ====================
public defn export-to-cad () :
  export-cad(["vendor_part_numbers.lcsc" => "LCSC"])
  export-cad(["vendor_part_numbers.lcsc" => "LCSC"])

; ====================
; Export design to CAD
; ====================
public defn export-design () :
  set-export-board?(true)
  export-to-cad()

; ===================================
; Update CAD, keeping layout progress
; ===================================
public defn update-design () :
  set-export-board?(false)
  export-to-cad()

; =================
; Setup BOM stuff
; =================
; BOMField
; jitx/BOMFieldStatus
; jitx/BOMFieldDescription
; jitx/BOMFieldInsts
; jitx/BOMFieldDatasheet
; jitx/BOMFieldManufacturer
; jitx/BOMFieldMPN
; jitx/BOMFieldVendor
; jitx/BOMFieldSKU
; jitx/BOMFieldQuantity
; jitx/BOMFieldPrice
; jitx/BOMFieldSubtotal
; jitx/BOMFieldPreferred

public defn setup-bill-of-materials (qty:Int, vendors:Tuple<String>) :
  set-bom-metrics([
    BOMMetric(BOMMetricLineItems, "Line Items"),
    BOMMetric(BOMMetricComponentCount, "Components"),
    BOMMetric(BOMMetricTotalCost, "Cost")
  ])
  set-bom-columns([
    BOMColumn(BOMFieldStatus, "Status", 10.0)
    BOMColumn(BOMFieldQuantity, "Qty", 5.0)
    BOMColumn(BOMFieldInsts, "References", 10.0)
    BOMColumn(BOMFieldMPN, "MPN", 10.0)
    BOMColumn(BOMFieldManufacturer, "Manufacturer", 10.0)
    BOMColumn(BOMFieldDescription, "Description", 20.0)
    BOMColumn(BOMFieldVendor, "Supplier", 10.0)
    BOMColumn(BOMFieldSKU, "SKU", 10.0)
    BOMColumn(BOMFieldDatasheet, "Datasheet", 10.0)
    BOMColumn(BOMFieldPreferred, "Preferred", 5.0)
  ])

  set-bom-vendors(vendors)
  set-bom-design-quantity(qty)

public defn bom-view-export () :
  view-bom(BOM-STD)
  export-bom()

doc: \<DOC>
The pcb-routing-structure(s) below are just examples of the routing structures that need to be maintained
in the project code because they are dependant on the stack-up and other factors.
<DOC>
public pcb-routing-structure rf-constraint :
  name = "50 Ohm RF single-ended routing structure"
  layer-constraints(Top) :
    trace-width = 0.500  ; mm
    clearance   = 0.200  ; mm
    velocity = 0.19e12   ; mm/s
    insertion-loss = 0.008  ; db/mm @ 1GHz
    neck-down = NeckDown(
      trace-width = 0.127
      clearance = 0.127
    )

doc: \<DOC>
@brief Apply the RF routing structure to a signal.
The function applies the provided pcb-routing-structure
to the signal between the start and endpoint. Note that both start and end points
need to be connected to physical component pins either directly or via pin assignment.
<DOC>

public defn rf-routing-structure (rs:RoutingStructure, x:JITXObject, y:JITXObject) :
  inside pcb-module :
    structure(x => y) = rs

public defn setup-supply-rail (pwr : JITXObject, supply-V : Toleranced) :
  inside pcb-module:
    public net VDD (pwr.V+)
    public net GND (pwr.V-)
    symbol(GND) = ocdb/utils/symbols/ground-sym
    symbol(VDD) = ocdb/utils/symbols/supply-sym
    property(GND.voltage) = typ(0.0)
    property(VDD.voltage) = supply-V
    ; use routing structure instead of net=class property here

    ; property(VDD.net-class) = NetClass(`Vdd, [`min-trace => 0.250])


; 50 ohm line on a 1.5mm h CBCPW

; public val CBCPW = NetClass(`ANT, [`min-trace => 0.5 `min-space => 0.2])

; via stitching function
public defn via-stitch (board-shape, connection) :
  inside pcb-module :
    ; board edge stitching vias
    val x-span = width(board-shape)
    val y-span = height(board-shape)

    val bot-y-coord = -1.0 * y-span / 2.0 + 0.595
    val bot-x-coord-start = -1.0 * x-span / 2.0 + 0.7
    val num-vias-bottom = to-int((x-span - 5.0 - 1.0))
    for x in 0 to num-vias-bottom do :
      val x-d = to-double(x)
      geom(connection) :
        via(small-via) at Point(bot-x-coord-start + x-d, bot-y-coord)

    val num-vias-left = to-int((y-span - 2.0))
    val left-x-coord = -1.0 * x-span / 2.0 + 0.594
    val bot-y-coord-start = -1.0 * y-span / 2.0 + 1.5
    for y in 0 to num-vias-left do :
      val y-d = to-double(y)
      geom(connection) :
        via(small-via) at Point(left-x-coord, bot-y-coord-start + y-d)

    val top-y-coord = y-span / 2.0 - 0.595
    val top-x-coord-start = -1.0 * x-span / 2.0 + 1.5
    val num-vias-top = to-int((x-span - 5.0 - 2.0)) - 1
    for x in 0 to num-vias-top do :
      val x-d = to-double(x)
      geom(connection) :
        via(small-via) at Point(top-x-coord-start + x-d, top-y-coord)


; ========================================================
; =================== Indicators =========================
; ========================================================

; 50 - 200 mcd for daylight
; 4 - 10 mcd for indoor

; Adds an RGB led to a processor using PWM pins
public defn rgb-indicator (brightness:Double, proc:JITXObject, vin:JITXObject):
  inside pcb-module:
    pcb-module rgb-indicator :
      port control-pins : timer[3]
      val vio = 3.3
      ; Calculate resistance to get appropriate brightness
      defn calc-r (l:JITXObject, brightness:Double, vio:Double):
        val i = PWL(property(l.mcd-current))[brightness]
        closest-std-val((vio - property(l.forward-voltage)) / i, percentage(5))
      public inst led : components/Foshan-NationStar-Optoelectronics/FM-B2020RGBA-HG/component ;
      insert-resistor(control-pins[0].timer, led.led.r, res-query resistance = calc-r(led.led.r, brightness, vio))
      insert-resistor(control-pins[1].timer, led.led.g, res-query resistance = calc-r(led.led.g, brightness, vio))
      insert-resistor(control-pins[2].timer, led.led.b, res-query resistance = calc-r(led.led.b, brightness, vio))

    inst rgb:rgb-indicator
    require control-pins:timer[3] from proc
    net (vin, rgb.led.led.a)
    net (control-pins rgb.control-pins)
    rgb

; Add load balancing caps to crystal oscillator
public defn add-xtal-load-caps (xtal:JITXObject, gnd:JITXObject, stray-capacitance:Double) :
  inside pcb-module:
    val c-load = load-capacitance(property(xtal.crystal-resonator))
    val c-bal = closest-std-val(2.0 * (c-load - stray-capacitance), percentage(5))
    ; insert-capacitor(xtal.OSC1, gnd, ["capacitance" => c-bal "temperature-coefficient.code" => "C0G" ])
    insert-capacitor(xtal.OSC1, gnd, c0g-cap-query capacitance = c-bal)
    ; val c = insert-capacitor(xtal.OSC2, gnd, ["capacitance" => c-bal "temperature-coefficient.code" => "C0G" ])
    val c = insert-capacitor(xtal.OSC2, gnd, c0g-cap-query capacitance = c-bal)
    c
; Default stray capacitance assumed 5pf.
public defn add-xtal-load-caps (xtal:JITXObject, gnd:JITXObject) :
  add-xtal-load-caps(xtal, gnd, 5.0e-12)
