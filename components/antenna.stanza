#use-added-syntax(jitx)
defpackage components/antenna :
  import core
  import jitx
  import jitx/commands
  import ocdb/utils/checks
  import ocdb/utils/generic-components
  import ocdb/utils/generator-utils
  import ocdb/utils/landpatterns
  import ocdb/utils/symbols
  import ocdb/utils/defaults

  import helpers
; ========================================================
; ===================== Antennas =========================
; ========================================================

pcb-landpattern antenna-2GHz4-inverted-f-geometry :

  pcb-pad launch-pad :
    name  = "Ant Launch Pad"
    type  = SMD
    shape = Polygon([Point(-0.25, -0.25)
                    ; Game the "center" point choice.
                    Point(-0.15, -0.25) Point(0.0, -0.25) Point(0.15, -0.25)
                    Point(0.25, -0.25)
                    Point(0.25, 1.25) Point(-0.25, 1.25)])

  pad launch : launch-pad at loc(0.0, 0.25)
  pad gnd : smd-pad(0.9, 0.5) at loc(-2.1, 0.25)

  copper(LayerIndex(0)) = Line(0.5, [Point(-2.1, 5.15), Point(2.2, 5.15), Point(2.2, 2.51), 
                                Point(4.7, 2.51),  Point(4.7, 5.15), Point(6.9, 5.15), 
                                Point(6.9, 2.51),  Point(9.4, 2.51), Point(9.4, 5.15), 
                                Point(11.6, 5.15), Point(11.6, 0.96)])
  ; copper(LayerIndex(0)) = Line(0.5, [Point(0.0, 0.0),   Point(0.0, 5.15)])
  ; copper(LayerIndex(0)) = Rectangle(0.9, 5.4, loc(-2.1, 2.7))
  layer(ForbidCopper(LayerIndex(0), LayerIndex(0, Bottom))) = Rectangle(20.0, 5.5, loc(5.0, 3.25))
  copper(LayerIndex(0)) = Rectangle(0.5, 4.10 loc(0., 3.325)) ; [Point(0.0, 0.0),   Point(0.0, 5.15)])
  copper(LayerIndex(0)) = Rectangle(0.9, 4.9, loc(-2.1, 2.95))
  layer(SolderMask(Top)) = Rectangle(20.0, 5.5, loc(5.0, 3.25))
  layer(Courtyard(Top)) = Rectangle(20.0, 5.5, loc(5.0, 3.25))
  layer(Courtyard(Bottom)) = Rectangle(20.0, 5.5, loc(5.0, 3.25))
  layer(BoardEdge()) = Line(0.0, [Point(17.0, 6.0), Point(-7.0, 6.0)])
  ref-label()

public pcb-component inverted-f-antenna-component :
  pin launch
  pin gnd
  description = "2.4 GHz Inverted F trace antenna"
  val pkg = antenna-2GHz4-inverted-f-geometry
  val sym = antenna-symbol(1, 1)
  landpattern = pkg(launch => pkg.launch, gnd => pkg.gnd)
  symbol = sym(launch => sym.p[1], gnd => sym.p[2])
  reference-prefix = "ANT"
  property(self.rated-temperature) = false

pcb-module pi-filter :
  ; @TODO - parameterization
  pin vin
  pin vout
  pin gnd

  inst C-F : ceramic-cap(["capacitance" => 0.8e-12 "temperature-coefficient.code" => "C0G" "case" => "0402"])
  inst C-R : ceramic-cap(["capacitance" => 0.5e-12 "temperature-coefficient.code" => "C0G" "case" => "0402"])
  inst L : smd-inductor(["inductance" => 4.7e-9 "min-self-resonant-frequency" => 7.0e6 "min-quality-factor" => 8.0 "case" => "0402"])

  ; @TODO - here is where I want to use `Network.stanza` to make this
  ;   more expressive and readable.
  net A (vin C-F.p[1] L.p[1])
  net B (vout L.p[2] C-R.p[1])
  net (gnd C-F.p[2] C-R.p[2])

  property(A.net-class) = CBCPW
  property(B.net-class) = CBCPW

  schematic-group(self) = PI-FILTER
  place(C-F) at loc( 1.100, 0.600, 0.0) on Top
  place(C-R) at loc(-1.100, 0.600, 0.0) on Top
  place(L) at loc(0.000, 1.00, 270.00) on Top

public pcb-module inverted-f-antenna :
  pin rf-in
  pin gnd

  public inst ant : inverted-f-antenna-component
  instance-status(ant) :
    bom-status = NotInBOM

  place(ant) at loc(0.0, 0.0, 0.0) on Top
  ; PI filter
  public inst pi : pi-filter
  ; place(pi) at loc(0.0, 0.0, 0.0) on Top

  net RF-IN (rf-in pi.vin)
  net LAUNCH (pi.vout ant.launch)
  net GND (gnd, ant.gnd pi.gnd)

  property(RF-IN.net-class) = CBCPW
  property(LAUNCH.net-class) = CBCPW

  schematic-group(self) = inverted-f-antenna

  val y = -0.1
  for x in 0 to 19 do :
    if (x < 4 or x > 5) and (x < 7 or x > 11):
      val x-d = to-double(x)
      geom(GND) :
        via(minimum-via) at Point(x-d - 4.4, y)
  
; view(inverted-f-antenna-component)

public pcb-module test-RF-conn :
  pin sig
  pin gnd

  ; We add a u.FL connector with a separate inductor and capacitor that are
  ;   generally DNP. This will be used for FCC verification.
  inst C-R : ceramic-cap(["capacitance" => 0.5e-12 "temperature-coefficient.code" => "C0G" "case" => "0402"])
  inst L : smd-inductor(["inductance" => 4.7e-9 "min-self-resonant-frequency" => 7.0e6 "min-quality-factor" => 8.0 "case" => "0402"])
  inst test-uFL : components/HRS/U-FL-R-SMT-10-/component

  net SIG (sig, L.p[1])
  net TEST-LAUNCH (L.p[2], C-R.p[1], test-uFL.sig)
  net (gnd, C-R.p[2], test-uFL.gnd)

  dnp([C-R, L, test-uFL])

  property(SIG.net-class) = CBCPW
  property(TEST-LAUNCH.net-class) = CBCPW
