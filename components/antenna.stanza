#use-added-syntax(jitx)
defpackage components/antenna :
  import core
  import jitx
  import jitx/commands
  import ocdb/utils/checks
  import ocdb/utils/generic-components
  import ocdb/utils/generator-utils
  import ocdb/utils/landpatterns
  import ocdb/utils/symbols
  import ocdb/utils/defaults

  import helpers
  import jsl/si

; ========================================================
; ===================== Antennas =========================
; ========================================================

pcb-landpattern antenna-2GHz4-inverted-f-geometry :

  pcb-pad launch-pad :
    name  = "Ant Launch Pad"
    type  = SMD
    shape = Polygon([Point(-0.25, -0.25)
                    ; Game the "center" point choice.
                    Point(-0.15, -0.25) Point(0.0, -0.25) Point(0.15, -0.25)
                    Point(0.25, -0.25)
                    Point(0.25, 1.25) Point(-0.25, 1.25)])

  pad launch : launch-pad at loc(0.0, 0.25)
  pad gnd : smd-pad(0.9, 0.5) at loc(-2.1, 0.25)

  copper(LayerIndex(0)) = Line(0.5, [Point(-2.1, 5.15), Point(2.2, 5.15), Point(2.2, 2.51), 
                                Point(4.7, 2.51),  Point(4.7, 5.15), Point(6.9, 5.15), 
                                Point(6.9, 2.51),  Point(9.4, 2.51), Point(9.4, 5.15), 
                                Point(11.6, 5.15), Point(11.6, 0.96)])
  ; copper(LayerIndex(0)) = Line(0.5, [Point(0.0, 0.0),   Point(0.0, 5.15)])
  ; copper(LayerIndex(0)) = Rectangle(0.9, 5.4, loc(-2.1, 2.7))
  layer(ForbidCopper(LayerIndex(0), LayerIndex(0, Bottom))) = Rectangle(20.0, 5.5, loc(5.0, 3.25))
  copper(LayerIndex(0)) = Rectangle(0.5, 4.10 loc(0., 3.325)) ; [Point(0.0, 0.0),   Point(0.0, 5.15)])
  copper(LayerIndex(0)) = Rectangle(0.9, 4.9, loc(-2.1, 2.95))
  layer(SolderMask(Top)) = Rectangle(20.0, 5.5, loc(5.0, 3.25))
  layer(Courtyard(Top)) = Rectangle(20.0, 5.5, loc(5.0, 3.25))
  layer(Courtyard(Bottom)) = Rectangle(20.0, 5.5, loc(5.0, 3.25))
  layer(BoardEdge()) = Line(0.0, [Point(17.0, 6.0), Point(-7.0, 6.0)])
  ref-label()

public pcb-component inverted-f-antenna-component :
  port launch
  port gnd
  description = "2.4 GHz Inverted F trace antenna"
  val pkg = antenna-2GHz4-inverted-f-geometry
  val sym = antenna-symbol(1, 1)
  landpattern = pkg(launch => pkg.launch, gnd => pkg.gnd)
  symbol = sym(launch => sym.p[1], gnd => sym.p[2])
  reference-prefix = "ANT"
  property(self.rated-temperature) = false

pcb-module pi-filter :
  ; @TODO - parameterization
  port vin
  port vout
  port gnd

  inst C-F : ceramic-cap(["capacitance" => 0.8e-12 "temperature-coefficient.code" => "C0G" "case" => "0402"])
  inst C-R : ceramic-cap(["capacitance" => 0.5e-12 "temperature-coefficient.code" => "C0G" "case" => "0402"])
  inst L : smd-inductor(["inductance" => 4.7e-9 "min-self-resonant-frequency" => 7.0e6 "min-quality-factor" => 8.0 "case" => "0402"])

  ; @TODO - here is where I want to use `Network.stanza` to make this
  ;   more expressive and readable.
  topo-net(vin => C-F.p[1] => L.p[1])
  pin-model(L.p[1] L.p[2]) = PinModel(typ(0.0), typ(0.0))
  topo-net(L.p[2] => C-R.p[1] => vout)
  net (gnd C-F.p[2] C-R.p[2])

  ; rf-routing-structure(rf-constraint, vin C-F.p[1])
  ; rf-routing-structure(rf-constraint, C-F.p[1] L.p[1])
  ; rf-routing-structure(rf-constraint, L.p[2] C-R.p[1])
  ; rf-routing-structure(rf-constraint, C-R.p[1] vout)

  schematic-group(self) = PI-FILTER
  place(C-F) at loc( 1.100, 0.600, 0.0) on Top
  place(C-R) at loc(-1.100, 0.600, 0.0) on Top
  place(L) at loc(0.000, 1.00, 270.00) on Top

public pcb-module inverted-f-antenna :
  port rf-in
  port gnd

  public inst ant : inverted-f-antenna-component
  instance-status(ant) :
    bom-status = NotInBOM

  place(ant) at loc(0.0, 0.0, 0.0) on Top
  ; PI filter
  public inst pi : pi-filter
  ; place(pi) at loc(0.0, 0.0, 0.0) on Top

  topo-net(rf-in pi.vin)
  topo-net(pi.vout ant.launch)
  net GND (gnd, ant.gnd pi.gnd)

  set-signal-end(rf-in, ant.launch)
  ; rf-routing-structure(rf-constraint, rf-in pi.vin)
  ; rf-routing-structure(rf-constraint, pi.vout ant.launch)

  ; property(RF-IN.net-class) = CBCPW
  ; property(LAUNCH.net-class) = CBCPW

  schematic-group(self) = inverted-f-antenna

  defn not-skip-index (a) -> True|False :
    a < 4 or a > 5 and a < 7 or a > 11

  val y = -0.1
  for x in 0 to 19 do :
    if not-skip-index(x) :
      val x-d = to-double(x)
      geom(GND) :
        via(minimum-via) at Point(x-d - 4.4, y)
  
; view(inverted-f-antenna-component)

public pcb-module test-RF-conn :
  port sig
  port gnd

  ; We add a u.FL connector with a separate inductor and capacitor that are
  ;   generally DNP. This will be used for FCC verification.
  inst C-R : ceramic-cap(["capacitance" => 0.5e-12 "temperature-coefficient.code" => "C0G" "case" => "0402"])
  inst L : smd-inductor(["inductance" => 4.7e-9 "min-self-resonant-frequency" => 7.0e6 "min-quality-factor" => 8.0 "case" => "0402"])
  inst test-uFL : components/HRS/U-FL-R-SMT-10-/module

  topo-net(sig => L.p[1])
  pin-model(L.p[1] L.p[2]) = PinModel(typ(0.0), typ(0.0))
  topo-net(L.p[2] => C-R.p[1] => test-uFL.sig)
  set-signal-end(sig, test-uFL.sig)
  
  net (gnd, C-R.p[2], test-uFL.gnd)

  dnp([C-R, L, test-uFL])

  ; rf-routing-structure(rf-constraint, sig L.p[1])
  ; rf-routing-structure(rf-constraint, L.p[2] C-R.p[1])
  ; rf-routing-structure(rf-constraint, C-R.p[1] test-uFL.sig)
  
  ; property(SIG.net-class) = CBCPW
  ; property(TEST-LAUNCH.net-class) = CBCPW
